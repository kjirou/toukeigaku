/**
 * # 本ライブラリにおける記述ルール
 * - 変数名・関数名は可能な限り日本語で記述する。
 *   - 専門用語を英語で表記するのは禁止する。
 *     - 「〜の最小値」などの専門用語に含まれるか不明な場合は、裁量の範囲とする。
 *   - 文法は英語に準拠し、関数の場合の先頭の動詞は英語にする。
 * - ファイル名など、日本語での表記が困難な場合は、日本式ローマ字で表記する。
 *   日本式ローマ字) https://ja.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC%E5%BC%8F%E3%83%AD%E3%83%BC%E3%83%9E%E5%AD%97
 * - コメントは不自然でない範囲で日本語で記述する。
 */


const create度数分布 = (データリスト, 階級数) => {
  const データリストの最小値 = Math.min(...データリスト);
  const データリストの最大値 = Math.max(...データリスト);

  const 度数分布 = [];
  let 累積度数 = 0;

  for (let i = 0; i < 階級数; i++) {
    // TODO: 階級を先頭から数えた場合の用語が不明。"第n階級" という表記は見つけたので、役割として存在はしてそう。
    const no = i + 1;
    const 階級の最小値 = (データリストの最大値 - データリストの最小値) / 階級数 * (no - 1);
    const 階級の最大値 = (データリストの最大値 - データリストの最小値) / 階級数 * no;
    const 度数 = データリスト.filter(データ => {
      // TODO: データが階級幅の中に含まれるかを「最小値以上-最大値未満」で判定している
      //       ネット資料（中高数学程度）しかなかったので、そういうものらしい？
      //       ただし、その場合は、データリストの最大値がどこにも含まれなくなるので場合分けしたが、
      //       これは出典なしである。
      if (i === 階級数 - 1) {
        return データ >= 階級の最小値 && データ <= 階級の最大値;
      } else {
        return データ >= 階級の最小値 && データ < 階級の最大値;
      }
    }).length;
    const 相対度数 = 度数 / データリスト.length;
    // TODO: 階級の範囲を累積的に計算してない一方でこれを累積しているのは、"累積"という単語に配慮した。
    //       そもそも階級数で割り切れない場合の閾値の処理が不明で、どちらも間違ってる可能性はある。
    //       ヒントになるかも = https://oshiete.goo.ne.jp/qa/8956085.html
    累積度数 += 相対度数;

    度数分布.push({
      no,
      階級の最小値,
      階級の最大値,
      階級値: (階級の最大値 - 階級の最小値) / 2 + 階級の最小値,
      度数,
      相対度数,
      累積度数,
    });
  }

  return 度数分布;
};


module.exports = {
  create度数分布,
};
