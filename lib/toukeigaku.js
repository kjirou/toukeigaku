// @flow

/**
 * # 本ライブラリにおける記述ルール
 * - 変数名・関数名は可能な限り日本語で記述する。
 *   - 専門用語を英語で表記するのは禁止する。
 *     - 「〜の最小値」などの専門用語に含まれるか不明な場合は、裁量の範囲とする。
 *   - 文法は英語に準拠し、関数の場合の先頭の動詞は英語にする。
 * - ファイル名など、日本語での表記が困難な場合は、日本式ローマ字で表記する。
 *   日本式ローマ字) https://ja.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC%E5%BC%8F%E3%83%AD%E3%83%BC%E3%83%9E%E5%AD%97
 * - コメントは不自然でない範囲で日本語で記述する。
 */

const Decimal = require('decimal.js');

/*::
export type DecimalValue = number | string;
 */


/**
 * 度数分布を作成する
 * @param データセット
 * @param 全階級の最小値 全階級を通じて最も小さい階級の最小値。この単語は独自定義。
 * @param 全階級の最大値 全階級を通じて最も大きい階級の最大値。この単語は独自定義。
 * @param 階級数
 * @param options
 * @param options.相対度数の丸め桁数 小数第何位までで丸めるか
 * @param options.相対度数の丸め手法
 */
const create度数分布 = (
  データセット/*: DecimalValue[]*/,
  全階級の最小値/*: DecimalValue*/,
  全階級の最大値/*: DecimalValue*/,
  階級数/*: number*/,
  options/*: {
    相対度数の丸め桁数?: number,
    相対度数の丸め手法?: "切り捨て" | "切り上げ" | "四捨五入",
  }*/ = {}
) => {
  const {
    相対度数の丸め桁数 = 2,
    相対度数の丸め手法 = '四捨五入',
  } = options;

  const 全階級の最小値_ = new Decimal(全階級の最小値);
  const 全階級の最大値_ = new Decimal(全階級の最大値);
  const 全階級幅 = 全階級の最大値_.minus(全階級の最小値_);
  const 度数分布 = [];
  let 累積度数 = new Decimal(0);
  let 累積相対度数 = new Decimal(0);

  for (let i = 0; i < 階級数; i++) {
    // TODO: 階級を先頭から数えた場合の用語が不明。"第n階級" という表記は見つけたので、役割として存在はしてそう。
    const no = i + 1;
    const 階級の最小値 = 全階級幅.div(階級数).mul(no - 1);
    const 階級の最大値 = 全階級幅.div(階級数).mul(no);
    const 階級幅 = 階級の最大値.minus(階級の最小値);
    const 度数 = データセット.filter(データ => {
      //
      // MEMO: 度数分布という概念の範囲の広さについて
      // --------------------------------------------
      //
      // データが階級幅の中に含まれるかを「最小値以上から最大値未満」で判定しているが、
      // 度数分布という概念の中には、必ずしもこうしろという定義はない。
      // また、階級幅は最後の階級のみ < が <= になった分広がっているが、
      // 上記と同じように、度数分布として階級幅が等幅であるという定義はない。
      //
      // これは、度数分布という概念がデータの可視性の向上という目的と切り離せない概念であり、
      // 見やすくするために、都合良く階級幅を調整することも考慮されているためである。
      //
      // 一方、ネットに存在する高校レベルの資料だと、
      // 「階級幅は最小値以上最大値未満で表現された等幅、しかし最後の階級のみ最大値は以上で判定される」
      // というのが暗黙的に前提になっていることが多い。
      //
      const データ_ = new Decimal(データ);
      if (i === 階級数 - 1) {
        return データ_.gte(階級の最小値) && データ_.lte(階級の最大値);
      } else {
        return データ_.gte(階級の最小値) && データ_.lt(階級の最大値);
      }
    }).length;
    累積度数 = 累積度数.plus(度数);
    // MEMO: "丸め" は "端数処理" や "端数計算" とも呼ばれる。
    //       どっちかというと "端数処理" という単語が最も一般的なよう。
    const 丸め前の相対度数 = 度数 / データセット.length;
    let 相対度数;
    switch (相対度数の丸め手法) {
      case '切り上げ':
        相対度数 = new Decimal(Math.ceil(丸め前の相対度数 * Math.pow(10, 相対度数の丸め桁数)))
          .div(Math.pow(10, 相対度数の丸め桁数));
        break;
      case '切り捨て':
        相対度数 = new Decimal(Math.floor(丸め前の相対度数 * Math.pow(10, 相対度数の丸め桁数)))
          .div(Math.pow(10, 相対度数の丸め桁数));
        break;
      case '四捨五入':
        相対度数 = new Decimal(丸め前の相対度数.toFixed(相対度数の丸め桁数));
        break;
      default:
        throw new Error('誤った相対度数の丸め手法です');
    }
    //
    // MEMO: 相対度数に端数が存在するときに累積相対度数が 100% にならない問題
    // ----------------------------------------------------------------------
    //
    // 各階級の相対度数に一つでも端数が存在する場合、累積相対度数はちょうど 100% にはならない。
    // 当ライブラリにおいては、100% に調整することはせず、単純に相対度数の合計を出力するものとする。
    //
    // なお、補足になるが、
    // https://archives.bukkyo-u.ac.jp/rp-contents/SO/0060/SO00600L111.pdf
    // の資料によると、この点は既存の統計学の表記でも問題になるところであり、
    // 大きく分けて以下の 3 つの対処があるらしい。
    //
    // 1) いずれかの階級の相対度数を調整して、累積相対度数が 100% ちょうどになるようにする。
    // 2) 調整せず、累積相対度数は 100% にならない。
    // 3) 調整せず、しかし累積相対度数は 100% と表記する。
    //
    // 当ライブラリにおいては、上記の 2 の方針に該当する。
    // また、上記資料によると
    // 「別段の理由があり 100% に調整する必要がある場合に、アドホックに調整をせず共通の手法に則るべき」
    // という主張も別途なされている。
    //
    累積相対度数 = 累積相対度数.plus(相対度数);

    度数分布.push({
      no,
      階級の最小値: 階級の最小値.toString(),
      階級の最大値: 階級の最大値.toString(),
      階級幅: 階級幅.toString(),
      階級値: 階級幅.div(2).plus(階級の最小値).toString(),
      度数,
      累積度数: 累積度数.toString(),
      相対度数: 相対度数.toFixed(相対度数の丸め桁数),
      累積相対度数: 累積相対度数.toFixed(相対度数の丸め桁数),
    });
  }

  return 度数分布;
};


module.exports = {
  create度数分布,
};
